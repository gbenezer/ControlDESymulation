{
  "hash": "23a7a7e1c2565d17dc313c20b7c78cda",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"ControlDESymulation: Design Philosophy and Architecture\"\nsubtitle: \"ControlDESymulation Architecture Documentation\"\nauthor: \"Gil Benezer\"\ndate: today\nformat:\n  html:\n    toc: true\n    code-fold: show\n    code-tools: true\nexecute:\n  eval: true      # Execute all code blocks\n  cache: true     # Cache results\n  warning: false  # Suppress warnings\n---\n\n## Executive Summary {#sec-executive-summary}\n\n**ControlDESymulation** is a Python library for symbolic specification and multi-backend simulation of nonlinear dynamical systems. It embodies a **type-driven, composition-based architecture** that achieves three seemingly contradictory goals simultaneously:\n\n1. **Mathematical Rigor** - Proper control theory, stochastic processes, and linearization\n2. **Software Engineering Excellence** - Clean architecture, zero duplication, extensive testing\n3. **Multi-Backend Performance** - Seamless NumPy/PyTorch/JAX with GPU/XLA support\n\nThe library consists of **~36,500 lines** across **39 core files** organized into **4 architectural layers**, serving researchers in control theory, robotics, and machine learning.\n\n## Core Design Philosophy {#sec-core-design-philosophy}\n\n### 1. Type-Driven Design {#sec-1-type-driven-design}\n\n**Principle:** *Types are not just annotations—they are the architecture.*\n\nThe entire framework is built on a **foundational type system** (200+ types) that provides:\n\n- **Semantic Clarity:** `StateVector`, `GainMatrix` instead of `np.ndarray`\n- **Type Safety:** Static checking via mypy/pyright catches errors before runtime\n- **IDE Support:** Autocomplete knows `result['t']` exists and is `TimePoints`\n- **Self-Documentation:** Type signatures encode mathematical constraints\n\n```python\n# Compare:\ndef bad(x, u):  # What are these? What dimensions? What backend?\n    return x + u\n\n# vs:\ndef good(x: StateVector, u: ControlVector) -> StateVector:\n    \"\"\"Clear: state in, control in, state out. Works with any backend.\"\"\"\n    return x + u\n```\n\n**Impact:** Every function signature is a mini-specification. New developers understand code by reading types.\n\n---\n\n### 2. Composition Over Inheritance {#sec-2-composition-over-inheritance}\n\n**Principle:** *Systems compose specialized utilities rather than inheriting monolithic bases.*\n\nTraditional OOP would create deep inheritance hierarchies. We rejected this in favor of **composition via delegation**:\n\n```python\n# NOT this (deep inheritance):\nclass System(BackendManager, CodeGenerator, DynamicsEvaluator, ...):\n    pass  # 50 methods, unclear responsibilities\n\n# YES this (composition):\nclass System:\n    def __init__(self):\n        self.backend = BackendManager()       # Multi-backend support\n        self._code_gen = CodeGenerator()      # Symbolic → numerical\n        self._dynamics = DynamicsEvaluator()  # Forward evaluation\n        self._linearization = LinearizationEngine()  # Jacobians\n        self.equilibria = EquilibriumHandler()  # Named equilibria\n```\n\n**Benefits:**\n\n- **Single Responsibility:** Each utility does one thing well\n- **Testability:** Test utilities in isolation\n- **Reusability:** Use BackendManager anywhere\n- **Clarity:** Explicit dependencies\n- **Flexibility:** Easy to swap implementations\n\n**Exception:** We DO use cooperative multiple inheritance in the UI framework—but only at the top level where it provides genuine value (avoiding duplication while maintaining clean interfaces).\n\n---\n\n### 3. Backend Agnosticism {#sec-3-backend-agnosticism}\n\n**Principle:** *Write once, run on NumPy/PyTorch/JAX without code changes.*\n\nSupporting multiple backends is not a feature—it's a **design constraint** that forces better architecture:\n\n```python\n# Same code works with all backends\ndef dynamics(x: StateVector, u: ControlVector) -> StateVector:\n    # x can be np.ndarray, torch.Tensor, or jax.Array\n    return -K @ x  # Works with all!\n\n# Backend switching is trivial\nsystem.set_default_backend('torch')\nsystem.set_default_device('cuda:0')\n```\n\n**Architectural Implications:**\n\n1. **ArrayLike Union Type:** All array types accept `Union[np.ndarray, torch.Tensor, jnp.ndarray]`\n2. **BackendManager Utility:** Centralized backend detection and conversion\n3. **Per-Backend Caching:** Code generated once per backend, then cached\n4. **Device Management:** Automatic GPU placement when available\n\n**Result:** Users can start with NumPy for prototyping, switch to PyTorch for neural ODEs, or JAX for optimization—with zero code changes.\n\n---\n\n### 4. Zero Code Duplication {#sec-4-zero-code-duplication}\n\n**Principle:** *Every line of code should exist in exactly one place.*\n\nWe eliminated ~1,800 lines of duplication between continuous and discrete systems through **strategic abstraction**:\n\n**Before:** Continuous and discrete systems each had:\n\n- Parameter handling\n- Backend management\n- Code generation\n- Symbolic validation\n- Configuration persistence\n\n**After:** SymbolicSystemBase provides shared functionality:\n\n- All parameter logic: **ONE** implementation\n- All backend logic: **ONE** BackendManager\n- All code generation: **ONE** CodeGenerator\n- All validation: **ONE** SymbolicValidator\n\n**How:** Cooperative multiple inheritance with clear layer separation:\n```\nLayer 0: SymbolicSystemBase (shared foundation)\nLayer 1: ContinuousSystemBase, DiscreteSystemBase (time-domain specific)\nLayer 2: ContinuousSymbolicSystem, DiscreteSymbolicSystem (multiple inheritance)\n```\n\nThis isn't inheritance for convenience—it's **strategic abstraction to eliminate duplication while maintaining clarity**.\n\n---\n\n### 5. Structured Results via TypedDict {#sec-5-structured-results-via-typeddict}\n\n**Principle:** *Never return plain dictionaries—use TypedDict for structure and safety.*\n\n```python\n# BAD: Plain dict (no IDE support, no type checking)\ndef integrate() -> dict:\n    return {'t': t, 'x': x, 'success': True}\n\n# GOOD: TypedDict (type-safe, self-documenting)\ndef integrate() -> IntegrationResult:\n    return {\n        't': t,              # TimePoints - IDE knows this\n        'x': x,              # StateTrajectory - IDE knows this\n        'success': True,     # bool - IDE knows this\n        'nfev': 100,        # int - Required field\n        'integration_time': 0.5,\n        'solver': 'RK45'\n    }\n```\n\n**Benefits:**\n\n- Type checker ensures all required fields present\n- IDE autocompletes field names\n- Documentation embedded in type definition\n- Optional fields clearly marked (`total=False`)\n- Refactoring safe (rename propagates)\n\n**Used Throughout:**\n\n- `IntegrationResult` - ODE integration\n- `SDEIntegrationResult` - SDE integration  \n- `ExecutionStats` - Performance metrics\n- `ValidationResult` - System validation\n- `BackendConfig` - Configuration\n\n---\n\n### 6. Protocol-Based Interfaces {#sec-6-protocol-based-interfaces}\n\n**Principle:** *Define interfaces via Protocol (structural typing) not inheritance.*\n\nProtocols enable **duck typing with type safety**:\n\n```python\nfrom typing import Protocol\n\nclass DynamicalSystemProtocol(Protocol):\n    \"\"\"Any class satisfying this structure is a dynamical system.\"\"\"\n    @property\n    def nx(self) -> int: ...\n    \n    @property\n    def nu(self) -> int: ...\n    \n    def __call__(self, x: StateVector, u: ControlVector) -> StateVector: ...\n\n# No inheritance needed!\nclass MySystem:  # Doesn't inherit from anything\n    @property\n    def nx(self) -> int:\n        return 2\n    \n    @property  \n    def nu(self) -> int:\n        return 1\n    \n    def __call__(self, x: StateVector, u: ControlVector) -> StateVector:\n        return x + u\n\n# Satisfies protocol structurally\nsystem: DynamicalSystemProtocol = MySystem()  # Type checker approves!\n```\n\n**Benefits:**\n\n- No inheritance coupling\n- Structural subtyping (like Go interfaces)\n- Easy to implement interfaces\n- Compose protocols naturally\n- Third-party types work automatically\n\n---\n\n### 7. Factory Pattern for Complex Creation {#sec-7-factory-pattern-for-complex-creation}\n\n**Principle:** *Hide complexity behind simple factory methods.*\n\nCreating integrators involves choosing backends, methods, and configurations. Factories simplify:\n\n```python\n# Instead of this complexity:\nif backend == 'numpy':\n    if method == 'RK45':\n        return ScipyIntegrator(system, method='RK45', rtol=1e-6)\n    elif method == 'Tsit5':\n        return DiffEqPyIntegrator(system, algorithm='Tsit5')\nelif backend == 'torch':\n    return TorchDiffEqIntegrator(system, method='dopri5')\n# ... 50 more cases\n\n# We provide this simplicity:\nintegrator = IntegratorFactory.auto(system)\n# or\nintegrator = IntegratorFactory.for_production(system)\n# or  \nintegrator = IntegratorFactory.for_neural_ode(system)\n```\n\n**Factory Methods:**\n\n- `auto()` - Best for system/backend\n- `for_production()` - LSODA/AutoTsit5\n- `for_optimization()` - JAX tsit5\n- `for_neural_ode()` - PyTorch dopri5\n- `for_julia()` - Highest performance\n- `create()` - Full control\n\n**Result:** Simple interface for common cases, full control when needed.\n\n---\n\n### 8. Semantic Naming {#sec-8-semantic-naming}\n\n**Principle:** *Names should convey mathematical meaning, not implementation details.*\n\n**Good Semantic Names:**\n\n- `StateVector` not `ArrayLike` - conveys it's a state\n- `GainMatrix` not `Matrix` - conveys it's for feedback control\n- `DynamicsEvaluator` not `FunctionCaller` - conveys purpose\n- `LinearizationEngine` not `JacobianComputer` - conveys operation\n\n**Bad Implementation Names:**\n\n- `data` - what data?\n- `arr1`, `arr2` - meaningless\n- `compute()` - compute what?\n- `process_stuff()` - what stuff?\n\n**Impact:** Code reads like mathematical papers. Control theorists immediately understand.\n\n---\n\n### 9. Progressive Disclosure of Complexity {#sec-9-progressive-disclosure-of-complexity}\n\n**Principle:** *Simple things should be simple, complex things should be possible.*\n\n**Level 1 - Simple (Beginner):**\n```python\nfrom controldesymulation.examples import Pendulum\n\nsystem = Pendulum()\nresult = system.simulate(x0, u=np.zeros(1), t_span=(0, 10))\n```\n\n**Level 2 - Intermediate:**\n```python\nfrom controldesymulation import ContinuousSymbolicSystem\nimport sympy as sp\n\nclass MySystem(ContinuousSymbolicSystem):\n    def define_system(self, m=1.0, k=10.0):\n        x, v = sp.symbols('x v', real=True)\n        u = sp.symbols('u', real=True)\n        \n        self.state_vars = [x, v]\n        self.control_vars = [u]\n        self._f_sym = sp.Matrix([v, -k*x/m + u/m])\n```\n\n**Level 3 - Advanced (Expert):**\n```python\n# Multi-backend, custom integrator, GPU acceleration\nsystem.set_default_backend('torch')\nsystem.to_device('cuda:0')\n\nintegrator = IntegratorFactory.create(\n    system,\n    backend='torch',\n    method='dopri5',\n    rtol=1e-9,\n    atol=1e-11,\n    adjoint=True  # Memory-efficient gradients\n)\n\nresult = integrator.integrate(\n    x0=torch.tensor([[1.0, 0.0]], device='cuda:0'),\n    u_func=lambda t, x: neural_controller(t, x),\n    t_span=(0.0, 10.0),\n    dense_output=True\n)\n```\n\n**Principle Applied:**\n\n- Default arguments for common cases\n- Progressive power through optional parameters\n- Expert features available but not mandatory\n\n---\n\n## Architectural Layers {#sec-architectural-layers}\n\nThe library consists of 4 distinct architectural layers, each with clear responsibilities:\n\n### Layer 0: Type System (Foundation) {#sec-layer-0-type-system-foundation}\n\n**Purpose:** Foundational types and structured results\n\n**Files:** 7 modules, 200+ types\n\n**Key Components:**\n\n- `core.py` - Vectors, matrices, functions\n- `backends.py` - Backend enums, configs\n- `trajectories.py` - Time series results\n- `linearization.py` - Jacobian types\n- `symbolic.py` - SymPy integration\n- `protocols.py` - Abstract interfaces\n- `utilities.py` - Type guards, helpers\n\n**Design Principles:**\n\n- Semantic over structural naming\n- Backend-agnostic unions\n- TypedDict for all results\n- Protocol-based interfaces\n\n**Impact:** Every layer above uses these types. Changes here propagate everywhere—so we keep them **stable and well-designed**.\n\n---\n\n### Layer 1: Delegation Layer (Services) {#sec-layer-1-delegation-layer-services}\n\n**Purpose:** Specialized utilities via composition\n\n**Files:** 11 modules\n\n**Key Components:**\n\n**Core Utilities:**\n\n- `BackendManager` - Multi-backend support\n- `CodeGenerator` - Symbolic → numerical\n- `EquilibriumHandler` - Named equilibria\n- `SymbolicValidator` - System validation\n\n**Deterministic Services:**\n\n- `DynamicsEvaluator` - Forward dynamics\n- `LinearizationEngine` - Jacobians\n- `ObservationEngine` - Output evaluation\n\n**Stochastic Services:**\n\n- `DiffusionHandler` - SDE diffusion\n- `NoiseCharacterizer` - Noise analysis\n- `SDEValidator` - SDE validation\n\n**Low-Level:**\n\n- `codegen_utils` - SymPy code generation\n\n**Design Principles:**\n\n- Single responsibility per utility\n- Composition not inheritance\n- Dependency injection\n- Lazy initialization with caching\n\n**Impact:** UI framework composes these utilities. Each utility is independently testable and reusable.\n\n---\n\n### Layer 2: Integration Framework (Numerical Methods) {#sec-layer-2-integration-framework-numerical-methods}\n\n**Purpose:** Multi-backend numerical integration\n\n**Files:** 13 modules\n\n**Key Components:**\n\n**Deterministic (ODE):**\n\n- `IntegratorBase` - Abstract interface\n- `IntegratorFactory` - Creation\n- `ScipyIntegrator` - NumPy scipy\n- `TorchDiffEqIntegrator` - PyTorch GPU\n- `DiffraxIntegrator` - JAX XLA\n- `DiffEqPyIntegrator` - Julia solvers\n- `FixedStepIntegrators` - Manual methods\n\n**Stochastic (SDE):**\n\n- `SDEIntegratorBase` - SDE interface\n- `SDEIntegratorFactory` - SDE creation\n- `TorchSDEIntegrator` - PyTorch SDE\n- `DiffraxSDEIntegrator` - JAX SDE\n- `DiffEqPySDEIntegrator` - Julia SDE\n- `CustomBrownianPath` - Custom noise\n\n**Design Principles:**\n\n- Factory pattern for creation\n- Unified result types (TypedDict)\n- Backend abstraction\n- Performance tracking\n\n**Supported Methods:** 40+ integration methods across 4 backends\n\n**Impact:** Users get production-grade integration with simple interfaces. Backend switching is trivial.\n\n---\n\n### Layer 3: UI Framework (User-Facing Systems) {#sec-layer-3-ui-framework-user-facing-systems}\n\n**Purpose:** Symbolic system definition and high-level interface\n\n**Files:** 8 modules\n\n**Key Components:**\n\n**Layer 0 - Foundation:**\n\n- `SymbolicSystemBase` - Time-agnostic base\n\n  - Symbolic variables/parameters\n  - Code generation orchestration\n  - Backend management\n  - Equilibrium handling\n  - Config persistence\n\n**Layer 1 - Time-Domain Bases:**\n\n- `ContinuousSystemBase` - Continuous interface\n- `DiscreteSystemBase` - Discrete interface\n\n**Layer 2 - Concrete Implementations:**\n\n- `ContinuousSymbolicSystem` - Continuous ODE\n- `DiscreteSymbolicSystem` - Discrete map\n\n**Layer 3 - Stochastic Extensions:**\n\n- `ContinuousStochasticSystem` - Continuous SDE\n- `DiscreteStochasticSystem` - Discrete stochastic\n\n**Special:**\n\n- `DiscretizedSystem` - Continuous → discrete\n\n**Design Principles:**\n\n- Cooperative multiple inheritance (strategic, not arbitrary)\n- Zero code duplication\n- Template method pattern\n- Composition for utilities\n\n**Impact:** Users define systems symbolically with clean interfaces. Framework handles all complexity.\n\n---\n\n## Design Patterns Used {#sec-design-patterns-used}\n\n### 1. Template Method Pattern {#sec-1-template-method-pattern}\n\n**Where:** All system base classes\n\n**How:** Base class defines workflow, subclasses fill in details\n\n```python\nclass SymbolicSystemBase(ABC):\n    def __init__(self, *args, **kwargs):\n        # 1. Call user's define_system()\n        self.define_system(*args, **kwargs)\n        \n        # 2. Validate\n        self._validator.validate(self)\n        \n        # 3. Initialize utilities\n        self._setup_utilities()\n        \n        # 4. Compile functions\n        self._compile()\n    \n    @abstractmethod\n    def define_system(self, **params):\n        \"\"\"User implements this.\"\"\"\n        pass\n```\n\n**Benefit:** Consistent initialization workflow. Users only implement `define_system()`.\n\n---\n\n### 2. Factory Method Pattern {#sec-2-factory-method-pattern}\n\n**Where:** IntegratorFactory, SDEIntegratorFactory\n\n**How:** Factory methods create appropriate concrete classes\n\n```python\nclass IntegratorFactory:\n    @classmethod\n    def create(cls, system, backend, method, **opts):\n        \"\"\"Create appropriate integrator based on inputs.\"\"\"\n        if backend == 'numpy':\n            if method in SCIPY_METHODS:\n                return ScipyIntegrator(system, method, **opts)\n            elif method in JULIA_METHODS:\n                return DiffEqPyIntegrator(system, method, **opts)\n        elif backend == 'torch':\n            return TorchDiffEqIntegrator(system, method, **opts)\n        # ...\n    \n    @classmethod\n    def auto(cls, system):\n        \"\"\"Best integrator for system.\"\"\"\n        backend = system.backend.default_backend\n        method = cls._BACKEND_DEFAULTS[backend]\n        return cls.create(system, backend, method)\n```\n\n**Benefit:** Users get right integrator without knowing details.\n\n---\n\n### 3. Strategy Pattern {#sec-3-strategy-pattern}\n\n**Where:** Integration methods\n\n**How:** Different algorithms (strategies) with same interface\n\n```python\n# All integrators implement same interface\nclass IntegratorBase(ABC):\n    @abstractmethod\n    def integrate(self, x0, u_func, t_span) -> IntegrationResult:\n        pass\n\n# Different strategies\nintegrator = ScipyIntegrator(system, method='RK45')  # Strategy 1\nintegrator = DiffraxIntegrator(system, method='tsit5')  # Strategy 2\n\n# Same interface\nresult = integrator.integrate(x0, u_func, t_span)\n```\n\n**Benefit:** Swap integration methods without code changes.\n\n---\n\n### 4. Dependency Injection {#sec-4-dependency-injection}\n\n**Where:** All delegation layer utilities\n\n**How:** Dependencies injected via constructor\n\n```python\nclass DynamicsEvaluator:\n    def __init__(\n        self,\n        system: SymbolicSystemBase,\n        code_gen: CodeGenerator,\n        backend_mgr: BackendManager\n    ):\n        # Dependencies injected, not created internally\n        self.system = system\n        self.code_gen = code_gen\n        self.backend_mgr = backend_mgr\n```\n\n**Benefit:** Easy to test (mock dependencies), clear dependencies.\n\n---\n\n### 5. Lazy Initialization {#sec-5-lazy-initialization}\n\n**Where:** Code generation, function compilation\n\n**How:** Generate/compile on first use, cache result\n\n```python\nclass CodeGenerator:\n    def generate_dynamics(self, backend):\n        # Check cache first\n        if self._f_funcs[backend] is not None:\n            return self._f_funcs[backend]  # Instant\n        \n        # Generate only if needed\n        func = self._compile_dynamics(backend)\n        \n        # Cache for next time\n        self._f_funcs[backend] = func\n        return func\n```\n\n**Benefit:** Fast startup, compile only what's needed.\n\n---\n\n### 6. Observer Pattern {#sec-6-observer-pattern}\n\n**Where:** Performance statistics, validation\n\n**How:** Utilities track events and report statistics\n\n```python\nclass DynamicsEvaluator:\n    def evaluate(self, x, u):\n        start = time.time()\n        result = self._f_func(x, u)\n        elapsed = time.time() - start\n        \n        # Update statistics\n        self._stats['calls'] += 1\n        self._stats['total_time'] += elapsed\n        \n        return result\n    \n    def get_stats(self) -> ExecutionStats:\n        return self._stats\n```\n\n**Benefit:** Built-in performance monitoring.\n\n---\n\n## Mathematical Rigor {#sec-mathematical-rigor}\n\n### Control Theory Foundations {#sec-control-theory-foundations}\n\nThe library implements proper control theory:\n\n**1. State-Space Representation**\n```\nContinuous:\n  dx/dt = f(x, u, t)\n  y = h(x, t)\n\nDiscrete:\n  x[k+1] = f(x[k], u[k])\n  y[k] = h(x[k])\n```\n\n**2. Linearization**\n```\nδẋ = A·δx + B·δu  (continuous)\nδx[k+1] = Ad·δx[k] + Bd·δu[k]  (discrete)\n\nwhere:\n  A = ∂f/∂x (state Jacobian)\n  B = ∂f/∂u (control Jacobian)\n```\n\n**3. Higher-Order Systems**\n```\nFor order n system q⁽ⁿ⁾ = f(q, q̇, ..., q⁽ⁿ⁻¹⁾, u):\n  State: x = [q, q̇, ..., q⁽ⁿ⁻¹⁾]ᵀ\n  Dynamics: ẋ = [q̇, q̈, ..., q⁽ⁿ⁾]ᵀ\n```\n\n**4. Stochastic Processes**\n```\nSDE (Itô): dx = f(x,u)dt + g(x,u)dW\nSDE (Stratonovich): dx = f(x,u)dt + g(x,u)∘dW\n\nNoise types:\n  - Additive: g(x,u) = G (constant)\n  - Multiplicative: g depends on x or u\n  - Diagonal: Independent noise channels\n  - Scalar: Single Wiener process\n```\n\n### Numerical Methods {#sec-numerical-methods}\n\n**ODE Solvers (40+ methods):**\n\n- Explicit RK: RK45, Tsit5, Vern9, dopri5\n- Implicit: Radau, BDF, Rodas5\n- Auto-stiffness: LSODA, AutoTsit5\n- Fixed-step: Euler, RK4, Midpoint\n\n**SDE Solvers:**\n\n- Euler-Maruyama (strong 0.5)\n- Milstein (strong 1.0, diagonal)\n- Heun (strong 1.0, additive)\n- Stochastic RK methods\n\n**Discretization:**\n\n- Exact (matrix exponential)\n- Tustin (bilinear transform)\n- Forward/backward Euler\n- Zero-order hold\n\n---\n\n## Performance Considerations {#sec-performance-considerations}\n\n### 1. Caching Strategy {#sec-1-caching-strategy}\n\n**Three-Level Cache:**\n\n1. **Symbolic Cache:** Jacobians computed once symbolically\n2. **Per-Backend Cache:** Compiled functions per backend\n3. **Equilibrium Cache:** Linearizations at equilibria\n\n**Example:**\n```python\n# First call: symbolic computation + compilation\nA, B = system.linearize(x_eq, u_eq)\n\n# Second call: cached\nA, B = system.linearize(x_eq, u_eq)\n```\n\n### 2. Backend Optimization {#sec-2-backend-optimization}\n\n**NumPy:**\n\n- Common subexpression elimination (CSE)\n- Fast numerical modules\n- Vectorized operations\n\n**PyTorch:**\n\n- Symbolic simplification before codegen\n- GPU tensor operations\n- Automatic differentiation\n- Adjoint method for memory\n\n**JAX:**\n\n- JIT compilation via `jax.jit`\n- XLA optimization\n- Pure functional style\n- Automatic vectorization (vmap)\n\n### 3. Batching Support {#sec-3-batching-support}\n\nAll evaluators support batched operations:\n\n```python\n# Single evaluation\ndx = system(x, u)  # x: (nx,), u: (nu,) → dx: (nx,)\n\n# Batched evaluation (possible 100x speedup over loop)\ndx_batch = system(x_batch, u_batch)  \n# x: (100, nx), u: (100, nu) → dx: (100, nx)\n```\n\n### 4. GPU Acceleration {#sec-4-gpu-acceleration}\n\n**PyTorch:**\n```python\nsystem.set_default_backend('torch')\nsystem.to_device('cuda:0')\n\nx = torch.tensor([[1.0, 0.0]], device='cuda:0')\ndx = system(x, u)  # Computed on GPU\n```\n\n**JAX:**\n```python\nsystem.set_default_backend('jax')\nsystem.to_device('cuda:0')\n\nx = jnp.array([1.0, 0.0])\ndx = jax.jit(system)(x, u)  # XLA compiled, GPU enabled\n```\n\n---\n\n## Testing Philosophy {#sec-testing-philosophy}\n\n### 1. Type-Driven Testing {#sec-1-type-driven-testing}\n\nTypes guide what to test:\n\n```python\ndef test_dynamics_signature():\n    \"\"\"Type annotations specify contract.\"\"\"\n    x: StateVector = np.array([1.0, 0.0])\n    u: ControlVector = np.array([0.5])\n    \n    dx: StateVector = system(x, u)\n    \n    assert isinstance(dx, np.ndarray)\n    assert dx.shape == (system.nx,)\n```\n\n### 2. Property-Based Testing {#sec-2-property-based-testing}\n\nTest mathematical properties:\n\n```python\ndef test_linearization_is_linear():\n    \"\"\"Linearization should be linear in δx and δu.\"\"\"\n    A, B = system.linearize(x_eq, u_eq)\n    \n    δx1, δx2 = np.random.randn(2, nx)\n    δu = np.zeros(nu)\n    \n    # Linearity: f(αx₁ + βx₂) = αf(x₁) + βf(x₂)\n    α, β = 0.3, 0.7\n    \n    lhs = A @ (α*δx1 + β*δx2)\n    rhs = α*(A @ δx1) + β*(A @ δx2)\n    \n    np.testing.assert_allclose(lhs, rhs)\n```\n\n### 3. Multi-Backend Consistency {#sec-3-multi-backend-consistency}\n\nSame results across backends:\n\n```python\ndef test_backend_consistency():\n    \"\"\"NumPy, PyTorch, JAX should agree.\"\"\"\n    x_np = np.array([1.0, 0.0])\n    \n    dx_np = system(x_np, backend='numpy')\n    dx_torch = system(torch.tensor(x_np), backend='torch')\n    dx_jax = system(jnp.array(x_np), backend='jax')\n    \n    np.testing.assert_allclose(dx_np, dx_torch.numpy())\n    np.testing.assert_allclose(dx_np, np.array(dx_jax))\n```\n\n### 4. Regression Testing {#sec-4-regression-testing}\n\nCritical numerical values frozen:\n\n::: {#203e0a15 .cell execution_count=1}\n``` {.python .cell-code}\ndef test_pendulum_energy_conservation():\n    \"\"\"Known system should have expected behavior.\"\"\"\n    system = Pendulum(m=1.0, l=1.0, g=9.81)\n    \n    # Energy should be conserved (no damping)\n    E0 = compute_energy(x0)\n    x_final = system.simulate(x0, u=None, t_span=(0, 10))[-1]\n    E_final = compute_energy(x_final)\n    \n    np.testing.assert_allclose(E0, E_final, rtol=1e-6)\n```\n:::\n\n\n---\n\n## Documentation Philosophy {#sec-documentation-philosophy}\n\n### 1. Self-Documenting Code {#sec-1-self-documenting-code}\n\nCode should be readable without comments:\n\n```python\n# Bad\ndef f(x, u, m):  # What is this?\n    return x[1], -m*x[0] + u\n\n# Good  \ndef compute_dynamics(\n    state: StateVector,\n    control: ControlVector,\n    stiffness: float\n) -> StateVector:\n    \"\"\"\n    Compute dynamics for mass-spring system.\n    \n    Args:\n        state: [position, velocity]\n        control: Applied force\n        stiffness: Spring constant k\n    \n    Returns:\n        [velocity, acceleration]\n    \"\"\"\n    position, velocity = state\n    force = control\n    acceleration = -stiffness * position + force\n    return np.array([velocity, acceleration])\n```\n\n### 2. Examples in Docstrings {#sec-2-examples-in-docstrings}\n\nEvery public function has usage examples:\n\n```python\ndef linearize(\n    self,\n    x_eq: EquilibriumState,\n    u_eq: EquilibriumControl\n) -> DeterministicLinearization:\n    \"\"\"\n    Compute linearization at equilibrium.\n    \n    Returns state and control Jacobians (A, B).\n    \n    Examples\n    --------\n    >>> # Linearize at origin\n    >>> A, B = system.linearize(\n    ...     x_eq=np.zeros(2),\n    ...     u_eq=np.zeros(1)\n    ... )\n    >>> print(A.shape)  # (2, 2)\n    >>> print(B.shape)  # (2, 1)\n    >>> \n    >>> # Check stability\n    >>> eigenvalues = np.linalg.eigvals(A)\n    >>> stable = np.all(np.real(eigenvalues) < 0)\n    \"\"\"\n```\n\n### 3. Mathematical Documentation {#sec-3-mathematical-documentation}\n\nExplain theory behind code:\n\n```python\n\"\"\"\nLinearization Engine for Dynamical Systems\n\nMathematical Background\n-----------------------\nFor a nonlinear system:\n    dx/dt = f(x, u)\n\nThe linearization at (x_eq, u_eq) is:\n    δẋ = A·δx + B·δu\n\nwhere:\n    A = ∂f/∂x|(x_eq, u_eq) ∈ ℝⁿˣˣⁿˣ  (State Jacobian)\n    B = ∂f/∂u|(x_eq, u_eq) ∈ ℝⁿˣˣⁿᵘ  (Control Jacobian)\n\nThis enables:\n- Stability analysis via eigenvalues of A\n- LQR controller design\n- Observer design (Kalman filter)\n- Small-signal analysis\n\"\"\"\n```\n\n### 4. Architecture Documents {#sec-4-architecture-documents}\n\nHigh-level guides (like this one!) explain design philosophy and patterns.\n\n---\n\n## Error Handling Philosophy {#sec-error-handling-philosophy}\n\n### 1. Fail Fast, Fail Clearly {#sec-1-fail-fast-fail-clearly}\n\nDetect errors as early as possible with clear messages:\n\n```python\n# Bad\ndef compute(x):\n    return x[5]  # IndexError: vague\n\n# Good\ndef compute(state: StateVector) -> float:\n    if len(state) < 6:\n        raise ValueError(\n            f\"State must have at least 6 elements for this computation. \"\n            f\"Got {len(state)} elements: {state}\"\n        )\n    return state[5]\n```\n\n### 2. Validation at Construction {#sec-2-validation-at-construction}\n\nCatch errors during `__init__`, not during use:\n\n```python\nclass System(SymbolicSystemBase):\n    def define_system(self):\n        # Bad parameter type\n        self.parameters = {'m': 1.0}  # String key!\n        \n# Validation catches this immediately:\n# ValueError: Parameter keys must be Symbol, not str.\n# Found string key: 'm'\n# Use: m_sym = sp.symbols('m'); parameters = {m_sym: 1.0}\n```\n\n### 3. Type Checking Before Runtime {#sec-3-type-checking-before-runtime}\n\nUse type annotations + mypy to catch errors before running:\n\n```{bash}\n$ mypy src/\nerror: Argument 1 to \"compute\" has incompatible type \"List[float]\"; \nexpected \"ndarray[Any, dtype[Any]]\"\n```\n\n### 4. Helpful Error Messages {#sec-4-helpful-error-messages}\n\nInclude context and solutions:\n\n```python\nif x.shape[0] != self.nx:\n    raise ValueError(\n        f\"State dimension mismatch.\\n\"\n        f\"Expected: {self.nx} (from system definition)\\n\"\n        f\"Got: {x.shape[0]} (from input)\\n\"\n        f\"State: {x}\\n\"\n        f\"Hint: Check that state vector has correct dimension.\"\n    )\n```\n\n---\n\n## Extension Points {#sec-extension-points}\n\nThe architecture provides clear extension points:\n\n### 1. Add New System Type {#sec-1-add-new-system-type}\n\n```python\nclass MyCustomSystem(SymbolicSystemBase):\n    \"\"\"Just implement define_system().\"\"\"\n    def define_system(self, **params):\n        # Define symbolic system\n        self.state_vars = [...]\n        self._f_sym = sp.Matrix([...])\n        self.parameters = {...}\n\n    # optionally implement setup equilibria to\n    # auto-set system equilibria with custom code\n    # upon instantiation\n    def setup_equilibria(self, *args, **kwargs):\n        # define how equilibria should be set up\n```\n\n### 2. Add New Integrator {#sec-2-add-new-integrator}\n\n```python\nclass MyIntegrator(IntegratorBase):\n    \"\"\"Implement abstract methods.\"\"\"\n    def step(self, x, u, dt):\n        # Single step logic\n        pass\n    \n    def integrate(self, x0, u_func, t_span):\n        # Multi-step logic\n        return IntegrationResult(...)\n```\n\n### 3. Add New Utility {#sec-3-add-new-utility}\n\n```python\nclass MyUtility:\n    \"\"\"Independent utility via composition.\"\"\"\n    def __init__(self, system):\n        self.system = system\n    \n    def my_operation(self):\n        # Custom operation\n        pass\n\n# Use via composition\nsystem._my_utility = MyUtility(system)\n```\n\n### 4. Add New Backend {#sec-4-add-new-backend}\n\n```python\n# 1. Add to Backend type\nBackend = Literal[\"numpy\", \"torch\", \"jax\", \"my_backend\"]\n\n# 2. Extend BackendManager\nclass BackendManager:\n    def _convert_to_backend(self, arr, backend):\n        if backend == \"my_backend\":\n            return my_backend.array(arr)\n        # ...\n\n# 3. Add to codegen_utils\ndef generate_function(expr, vars, backend):\n    if backend == \"my_backend\":\n        return my_backend.lambdify(...)\n    # ...\n```\n\n---\n\n## Trade-offs and Decisions {#sec-trade-offs-and-decisions}\n\n### 1. Cooperative Multiple Inheritance {#sec-1-cooperative-multiple-inheritance}\n\n**Decision:** Use cooperative multiple inheritance ONLY in UI framework Layer 2\n\n**Rationale:**\n\n- **Pro:** Eliminates ~1,800 lines of duplication\n- **Pro:** Clean interfaces (ContinuousSymbolicSystem has both symbolic and continuous capabilities)\n- **Pro:** Python's MRO handles it correctly with `super()`\n- **Con:** Can be confusing if overused\n- **Con:** Requires careful design\n\n**Why Limited Use:** We restrict it to where it provides genuine value—the top-level system classes that need to inherit both symbolic machinery and time-domain interfaces.\n\n### 2. TypedDict vs Dataclass {#sec-2-typeddict-vs-dataclass}\n\n**Decision:** Use TypedDict for results, not dataclass\n\n**Rationale:**\n\n- **Pro:** Compatible with plain dictionaries (gradual typing)\n- **Pro:** No runtime overhead\n- **Pro:** Works with JSON serialization\n- **Con:** Not as pythonic as dataclass\n- **Con:** No default values (use `total=False` instead)\n\n**Why TypedDict:** Integration results come from external libraries (scipy, etc.) as dictionaries. TypedDict lets us type them without conversion.\n\n### 3. Backend Support {#sec-3-backend-support}\n\n**Decision:** Support NumPy, PyTorch, JAX (not TensorFlow)\n\n**Rationale:**\n- **NumPy:** Universal, stable, CPU\n- **PyTorch:** Neural networks, GPU, mature ecosystem\n- **JAX:** Functional, JIT, XLA, research-friendly\n- **TensorFlow:** Skipped due to complexity, declining use in research\n\n**Why These Three:** Cover 95% of use cases with minimal complexity.\n\n### 4. Symbolic Engine {#sec-4-symbolic-engine}\n\n**Decision:** Use SymPy (not custom symbolic engine)\n\n**Rationale:**\n- **Pro:** Mature, well-tested symbolic math\n- **Pro:** Excellent documentation\n- **Pro:** Large community\n- **Con:** Can be slow for very large systems\n- **Con:** Limited control over simplification\n\n**Why SymPy:** Reinventing symbolic math is not our value proposition. SymPy is battle-tested.\n\n### 5. Testing Framework {#sec-5-testing-framework}\n\n**Decision:** pytest (not unittest)\n\n**Rationale:**\n- **Pro:** Less boilerplate\n- **Pro:** Better fixtures\n- **Pro:** Parametrized tests\n- **Pro:** Better assertions\n\n**Why pytest:** Industry standard, developer-friendly.\n\n---\n\n## Future Directions {#sec-future-directions}\n\n### Features Actively Being Worked On Prior to Release {#sec-features-actively-being-worked-on-prior-to-release}\n\n1. **Classical Control Theory**\n    - Stability, controllability, and observability metrics\n    - Kalman Filter, Luenberger Observer design\n    - Linear Quadratic (Gaussian) Regulator control design\n    - Callable controllers\n\n2. **Visualization**\n    - Plotting using Plotly\n        - Trajectory visualization across all variables\n        - Phase portrait visualization in two or three dimensions\n\n### Planned Features {#sec-planned-features}\n\n1. **RL Environment Synthesis**\n    - Interfaces that satisfy Gymnasium library conventions\n    - Export of Gymnasium and/or PyBullet environments from symbolically defined dynamics\n\n2. **Synthetic Data Generation**\n    - Classes and methods for the generation and export of synthetic physical data in standard formats\n\n3. **Parameter and Uncertainty Estimation**\n   - System identification\n   - Bayesian inference\n   - Adaptive control\n   - Conformal methods\n   - Sobol indices\n   - Morris screening\n\n3. **Neural Controller Design**\n    - Protocol interface for backend-agnostic functionality\n    - Neural controller training\n    - Neural certificate function construction and verification \n        - Lyapunov, barrier, contraction metric\n    - Forward and backward reachability analysis\n\n4. **Model Predictive Control (MPC)**\n   - Receding horizon optimization\n   - Constraint handling\n   - Real-time capable\n   - Integration with do-mpc, CasADi, acados\n\n5. **Advanced Stochastic**\n   - Particle filters\n   - Stochastic MPC\n   - Noisy measurement models\n   - Other robust and/or stochastic control\n\n6. **System Composition**\n    - Connector protocol interfaces to couple multiple subsystems\n\n### Potential Future Extensions {#sec-potential-future-extensions}\n\n1. Hybrid Systems\n    - Switched dynamics\n    - Hybrid automata\n    - Jump/flow dynamics\n\n2. Distributed Systems\n    - Multi-agent dynamics\n    - Network topology\n    - Consensus protocols\n\n3. Delay Systems\n    - Time-delayed feedback\n    - DDE integration\n    - Delayed stability analysis\n\n3. PDE Systems\n    - Spatiotemporal dynamics\n    - Finite/discrete element methods\n    - Spectral methods\n\n---\n\n## Conclusion {#sec-conclusion}\n\n**ControlDESymulation** demonstrates that **mathematical rigor**, **software engineering excellence**, and **multi-backend performance** are not competing goals—they are mutually reinforcing when built on a foundation of:\n\n1. **Type-Driven Design** - Types are architecture\n2. **Composition Over Inheritance** - Build with utilities\n3. **Backend Agnosticism** - Write once, run anywhere\n4. **Zero Duplication** - Strategic abstraction\n5. **Structured Results** - TypedDict everywhere\n6. **Protocol Interfaces** - Duck typing with safety\n7. **Factory Patterns** - Hide complexity\n8. **Semantic Naming** - Code reads like math\n\nThe result is a library where:\n- **Control theorists** find familiar mathematics\n- **Software engineers** find clean architecture\n- **ML researchers** find GPU acceleration\n- **Students** find gentle learning curves\n- **Experts** find power and flexibility\n\n**Code organized into 4 architectural layers, implementing 200+ types and 40+ integration methods—all serving a single vision: symbolic dynamical systems done right.**\n\n---\n\n## Appendix: Statistics Summary {#sec-appendix-statistics-summary}\n\n### Code Distribution {#sec-code-distribution}\n\n| Layer | Files | Lines | Purpose |\n|-------|-------|-------|---------|\n| Type System | 7 | 6,481 | Foundational types |\n| Delegation Layer | 11 | 7,198 | Service composition |\n| Integration Framework | 13 | ~10,000 | Numerical methods |\n| UI Framework | 8 | 12,820 | User interface |\n| **TOTAL** | **39** | **~36,500** | **Complete system** |\n\n### Type Distribution {#sec-type-distribution}\n\n| Category | Count | Examples |\n|----------|-------|----------|\n| Vector Types | 15+ | StateVector, ControlVector |\n| Matrix Types | 30+ | StateMatrix, GainMatrix |\n| Function Types | 10+ | DynamicsFunction, ControlPolicy |\n| Backend Types | 20+ | Backend, Device, NoiseType |\n| Trajectory Types | 15+ | StateTrajectory, IntegrationResult |\n| Linearization Types | 15+ | DeterministicLinearization |\n| Symbolic Types | 10+ | SymbolicExpression |\n| Protocol Types | 20+ | DynamicalSystemProtocol |\n| Utility Types | 20+ | ExecutionStats, TypeGuards |\n| TypedDict Results | 15+ | IntegrationResult |\n| **TOTAL** | **200+** | **Complete type system** |\n\n### Integration Methods {#sec-integration-methods}\n\n| Category | Count | Examples |\n|----------|-------|----------|\n| NumPy (scipy) | 6 | RK45, LSODA, BDF, Radau |\n| NumPy (Julia) | 20+ | Tsit5, Vern9, Rodas5, AutoTsit5 |\n| PyTorch | 8 | dopri5, dopri8, adaptive_heun |\n| JAX | 8 | tsit5, dopri5, heun, ralston |\n| Fixed-step | 3 | euler, midpoint, rk4 |\n| SDE Methods | 10+ | euler-maruyama, milstein, heun |\n| **TOTAL** | **55+** | **Comprehensive coverage** |\n\n### Design Patterns {#sec-design-patterns}\n\n| Pattern | Count | Where Used |\n|---------|-------|------------|\n| Template Method | 8 | All system base classes |\n| Factory Method | 2 | Integrator/SDE factories |\n| Strategy | 55+ | All integration methods |\n| Dependency Injection | 11 | All delegation utilities |\n| Lazy Initialization | 7 | Code generation, caching |\n| Observer | 5 | Performance statistics |\n| Protocol | 20+ | All structural interfaces |\n\n**The numbers tell the story: a comprehensive, well-architected library built on solid design principles.**\n\n",
    "supporting": [
      "cdesym_Design_Philosophy_files"
    ],
    "filters": [],
    "includes": {}
  }
}